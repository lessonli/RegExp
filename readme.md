

# 正则
## 什么是正则(Reg)
> 正则 全称 regular expression 常 简写为 regex regexp 或者 RE 翻译为 规则表达式 常规表达式

+ 用于 匹配字符串中 字符组合的模式  
  + 翻译一下 就是 用来 匹配 字符串的 一种规则
+ 正则表达式 也是对象
+ 这些模式 被用于 正则的 exec 和 test 方法
+ 以及 `String` 的 `match` `matchAll` `replace` `search` 和 `split`

## 正则表达式的创建

### 正则 表达式 
```ts
  type Iflag = g|i|m|s|u|y
  let flag:Iflag = i
  let reg = /abc/flag
```
#### reg flags 
|  flag   | desc  |
|  :-:  | :-: |
| g  | 全称 global 全局搜索 |
| i  |  不区分大小写 搜索  ignoreCase 忽略 大小写|
| m  |  多行搜索  multiline|
| s  | 允许 `.`匹配换行符|
| u  | 使用unicode 码的 模式 进行匹配 |
| y  | 执行 粘性搜索`sticky` 匹配从目标字符串的当前位置开始 |
### 构造函数 方式
```ts
  
  let flag 
  new RegExp('abc', flag)
```

## 元字符
|  元字符   | desc  |
|  :-:  | :-  |
|`\`| 转义 将一个 具有特殊标记的转换为 普通字符 如： 'n' '\n'  匹配换行符|
|`^`|匹配输入的开始 如果 多行标志 被设置为`true` 那么也匹配换行符后面紧跟的位置  当 '^' 作为第一个字符出现在一个字符集合模式时，如: '^abc'|
|`$`| 匹配输入的结束 如果多行表示被打开 那么也将 匹配换行符的前一个位置|
|`*`| 匹配前一个表达式 <mark>0或多次</mark> 等价于 `{0,}`|
|`+`|匹配前一个表达式 <b>1或多次</b> 等价于 `{1,}`|
|`?`|匹配前一个表达式 <b>0或1次</b> 等价于 `{0,1}` 如果紧跟`任何量词`<kbd>*</kbd> <kbd>+</kbd> <kbd>?</kbd> 或者 <kbd>{}</kbd> 的后面 将会使量词 变为 `非贪婪`<b>匹配尽量少的字符</b> 和缺省 使用的`贪婪模式`<b>尽可能多的匹配字符 刚好相反</b> 例如: '123abc' 使用 `/\d+/` 默认使用贪婪模式 将会匹配到 123  而使用 `/\d+?/` 将会启用 非贪婪模式 此时匹配到的就是 1|
|`.`|<kbd>.</kbd> 默认匹配除换行符之外的任何`单个字符` 如果开启多行模式 也会匹配到换行符|
|`(X)`|`括号在正则表达式中常用作记忆设备` 像下面的例子展示的那样，它会匹配 'x' 并且记住匹配项。其中括号被称为捕获括号。模式 /(foo) (bar) \1 \2/ 中的 '(foo)' 和 '(bar)' 匹配并记住字符串 "foo bar foo bar" 中前两个单词。模式中的 \1 和 \2 表示第一个和第二个被捕获括号匹配的子字符串，即 foo 和 bar，匹配了原字符串中的后两个单词。注意 \1、\2、...、\n 是用在正则表达式的匹配环节，详情可以参阅后文的 \n 条目。而在正则表达式的替换环节，则要使用像 $1、$2、...、$n 这样的语法，例如，'bar foo'.replace(/(...) (...)/, '$2 $1')。$& 表示整个用于匹配的原字符串。|
|`(?:x)`| <b>匹配 x 但是不记住 匹配项</b> 这种括号叫做非 捕获括号  使得能够定义与正则表达式运算法一起使用的 子表达式 `/(?:foo){1,2}/` 如果表达式 是 `/foo{1,2}/，{1,2}` 将只应用于foo 的最后一个字符 o 如果使用 非捕获括号 则会应用于 整个 foo 单词|
|x(?=y)| 匹配 仅仅当 <b>x后面 跟着y</b> 这种叫做先行断言  例如，/Jack(?=Sprat)/会匹配到'Jack'仅当它后面跟着'Sprat'。/Jack(?=Sprat|Frost)/匹配‘Jack’仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。 |
|`(?<=y)x`|匹配 'x'仅当x 前面是y 这种叫做 后行断言 例如，/(?<=Jack)Sprat/会匹配到' Sprat '仅仅当它前面是' Jack '。/(?<=Jack|Tom)Sprat/匹配‘ Sprat ’仅仅当它前面是'Jack'或者是‘Tom’。但是‘Jack’和‘Tom’都不是匹配结果的一部分。|
|`x(?!y)`| <b>仅仅 当 x 后面不跟着 y时 匹配x </b> 这被称作 正向否定查找 例如，仅仅当这个数字后面没有跟小数点的时候，/\d+(?!\.)/ 匹配一个数字。正则表达式/\d+(?!\.)/.exec("3.141") 匹配‘141’而不是‘3.141’|
|`(?<!y)x`|<b>反向否定查找 仅当x 前面不是 y 的时候 匹配</b> 例如，仅仅当这个数字前面没有负号的时候，/(?<!-)\d+/ 匹配一个数字。/(?<!-)\d+/.exec('3') 匹配到 "3"./(?<!-)\d+/.exec('-3') 因为这个数字前有负号，所以没有匹配到。|
|`x|y`| 匹配 x 或者 y|
|`{n}`|n是一个正整数 <b> 匹配前面一个 表达式 出现n 次</b>|
|`{n,}`|<b> 至少匹配n次</b> |
|`{n,m}`| <b><匹配前面的字符最少n次 最多m 次/b>|
|`[xyz]`|表示一个字符集合 匹配方括号中的任意字符 可以使用<kbd>-</kbd> 来指定一个集合的范围 <b>对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的</b>|
|`[^xyz]`| 一个反向字符集。也就是说，它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。|
|`[\b]`| `匹配一个退格 (U+0008)。（不要和\b混淆了。）`|
|`\b`| 匹配 一个字符的边界|
|`\B`|匹配一个 `非字符边界 `|
|`\d`| 匹配一个数字 等价于 `[0-9]`|
|`\D`| 匹配一个 非数字 等价于 `[^0-9]`|
|`\f`| 匹配一个换页符  (U+000C)|
|`\r`| 匹配一个回车符 (U+000D)。|
|`\s`| 匹配一个空白字符 包含 空格 制表符 换页 换行 |
|`\S`| 匹配一个 非空白支付|
|`\w`| 匹配一个数字字母下划线 等价于 `[1-9a-zA-Z_]`|
|`\W`| 匹配一个非数字字母下划线 等价于 `[^1-9a-zA-Z_]`|
|`\n`| 在正则表达式中，它返回最后的第 n 个子捕获匹配的子字符串 (捕获的数目以左括号计数)。比如 /apple(,)\sorange\1/ 匹配"apple, orange, cherry, peach."中的'apple, orange,' 。|
|`(?<name>exp)`|  匹配 exe 并捕获到名称为 name 到群组里|


## 正则的原型方法
|方法|描述|
|:-:|:-|
|`compile`| 已废弃 不做过多描述|
|`dotAll`| dotAll 属性表明是否在正则表达式中一起使用"s"修饰符（引入/s 修饰符，使得。可以匹配任意单个字符）。dotAll 是一个只读的属性，属于单个正则表达式实例|
|`sticky`||
|`falgs`|**flags**属性返回一个字符串，由当前正则表达式对象的标志组成。|
|`multiline`||
|`ignoreCase`| **ignoreCase** 属性表明正则表达式是否使用了 "i" 标志。ignoreCase 是正则表达式实例的只读属性。|
|`source`|source 属性返回一个值为当前正则表达式对象的模式文本的字符串，该字符串不会包含正则字面量两边的斜杠以及任何的标志字符|
|`global`|**global** 属性表明正则表达式是否使用了 "g" 标志。global 是一个正则表达式实例的只读属性。|
|`toString`| toString() 返回一个表示该正则表达式的字符串。|
|`exec`| exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。|
|`test`|test() 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false。 |

|以下方法都是字符串的|描述|
|:-:|:-|
|`match`| 对正则表达式匹配字符串时，**[@@match]()**方法用于获取匹配结果。 |
|`matchAll`| **[@@matchAll]**方法返回对字符串使用正则表达式的所有匹配项 返回一个迭代器对象。 [引用](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match)|
|`replace`| [@@replace]() 方法会在一个字符串中用给定的替换器，替换所有符合正则模式的匹配项，并返回替换后的新字符串结果。用来替换的参数可以是一个字符串或是一个针对每次匹配的回调函数。|
|`search`|[@@search]() 方法执行了一个在给定字符串中的一个搜索以取得匹配正则模式的项。|
|`split`| [@@split]() 方法切割 String 对象为一个其子字符串的数组 。|

 **matchAll**  
 + groups: 一个命名捕获组对象，其键是捕获组名称，值是捕获组，如果未定义命名捕获组，则为undefined。有关详细信息，请参阅组和范围。 
  + index: 匹配的结果的开始位置
  + input: 搜索的字符串。
  + 返回迭代器对象
<!-- ```ts
  let reg = /abc/
  type ISymbalFunction =  Symbal:{
        match:(str:string)=> any[]|null
        matchALl:(str:string)=> any[]|null
    }

``` -->

## 断言
 断言的组成之一是边界。对于文本、词或模式，边界可以用来表明它们的起始或终止部分（如向前断言，向后断言以及条件表达式）。

### 常见的断言 元字符 
#### 边界类断言
<p>
  <kbd>^</kbd> <kbd>$</kbd> <kbd>\b</kbd>  <kbd>\B</kbd> 
</p>

#### 其他断言
|字符|含义|
|:-:|:-|
|`(?:x)`| <b>匹配 x 但是不记住 匹配项</b> 这种括号叫做非 捕获括号  使得能够定义与正则表达式运算法一起使用的 子表达式 `/(?:foo){1,2}/` 如果表达式 是 `/foo{1,2}/，{1,2}` 将只应用于foo 的最后一个字符 o 如果使用 非捕获括号 则会应用于 整个 foo 单词|
|`x(?=y)`| 匹配 仅仅当 <b>x后面 跟着y</b> 这种叫做先行断言 向前断言  只有y前面是x 的时候 |
|`(?<=y)x`|匹配 'x'仅当x 前面是y 这种叫做 后行断言 向后断言 |
|`x(?!y)`| <b>仅仅 当 x 后面不跟着 y时 匹配x </b> 这被称作 正向否定查找 例如，仅仅当这个数字后面没有跟小数点的时候，/\d+(?!\.)/ 匹配一个数字。正则表达式/\d+(?!\.)/.exec("3.141") 匹配‘141’而不是‘3.141’|
|`(?<!y)x`|<b>反向否定查找 仅当x 前面不是 y 的时候 匹配x</b> 向后否定断言|


## 字符类
**区分数字和字符**
<p>
  <kbd>[xyz][a-c]</kbd> [^xyz] [^a-c]<kbd>.</kbd> <kbd>\d</kbd> <kbd>\D</kbd> <kbd>\w</kbd> <kbd>\W</kbd> <kbd>\s \t \ x|y ...kbd> 
</p>


## 组和范围 group and ranges

`x|y [xyz] [a-c] [^xyz] [^a-z] (x) \n (?<Name>x) (?:x)`

## 量词

`x* x+ x? x{n} x{n,} x{n,m} x*? x+? x?? x{n}? x{n,}? x{n,m}? `


